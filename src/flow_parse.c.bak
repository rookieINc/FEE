
/************************************************************
 * Copyright(C), 2015-2016, QTPAY
 * 
 * FileName    : flow_parse.c
 * Author      : rookieINc
 * Version     : v0.1.0
 * Date        : 2015-12-01 16:48
 * Description : flow_parse.c
 * History     :     
 ***********************************************************/

#include "kdk.h"
#include "flow_parse.h"

work_flow_data_t *
work_flow_data_init(kdk_void (*fill_data)(work_flow_data_t *))
{
    work_flow_data_t *data;

    data = (work_flow_data_t *)kdk_malloc(sizeof(work_flow_data_t));
    if(data == KDK_NULL)
        return KDK_NULL;
    
    fill_data(data);

    return data;
}

kdk_uint32 
get_id_from_work_flow(kdk_char32 *work_flow, kdk_char32 *work_id, kdk_uint32 work_id_len, kdk_uint32 *process_status, kdk_uint32 *offset)
{
    kdk_char32     *work_id_tail;
    kdk_uint32      new_status;

    if(work_flow == KDK_NULL || work_id == KDK_NULL || process_status == KDK_NULL || offset == KDK_NULL) 
        return KDK_INARG;

    *offset = 1;

/*此处应有注释*/
    switch(*process_status)
    {
        case PROCESS_NOR_STATUS:
            work_id_tail = strpbrk(work_flow, "-[");
            if(work_id_tail != KDK_NULL && *work_id_tail == '[')
                new_status = PROCESS_PRE_STATUS; 
            if(work_id_tail != KDK_NULL && *work_id_tail == '-')
                new_status = PROCESS_NOR_STATUS; 
            break;

        case PROCESS_PRE_STATUS:
            work_id_tail = strpbrk(work_flow, ",]");
            if(work_id_tail != KDK_NULL && *work_id_tail == ',')
                new_status = PROCESS_ERR_STATUS; 
            else if(work_id_tail != KDK_NULL && *work_id_tail == ']')
                new_status = PROCESS_NOR_STATUS; 
            break;

        case PROCESS_ERR_STATUS:
        case PROCESS_ERR_NOR_STATUS:
            work_id_tail = strpbrk(work_flow, "-]");
            if(work_id_tail != KDK_NULL && *work_id_tail == '-')
                new_status = PROCESS_ERR_NOR_STATUS; 
            else if(work_id_tail != KDK_NULL && *work_id_tail == ']')
                new_status = PROCESS_NOR_STATUS; 
            break;

        default:
            return KDK_INARG;
    }

/*此处应有注释*/
    if(work_id_tail == KDK_NULL)
    {
        if(*process_status == PROCESS_NOR_STATUS)
            *offset = *offset + strlen(work_flow);
        else
            return KDK_INARG;
    }
    else
    {
        *offset = *offset + (work_id_tail - work_flow) / sizeof(kdk_char32);
    }

    if(*offset > work_id_len)
        return KDK_INARG;

/*此处应有注释*/
    strncpy(work_id, work_flow, *offset - 1); 
    str_trim(work_id);

    if(strlen(work_id) == 0)
    {
/*此处应有代码*/
    }

/*此处应有注释*/
    *process_status = new_status;

    return KDK_SUCCESS;
}

kdk_uint32 
check_work_id(kdk_char32 *work_id)
{
    return KDK_SUCCESS;
}

work_flow_node_t *
work_flow_node_create(kdk_char32 *work_id)
{
    if(work_id == KDK_NULL) 
        return KDK_NULL;

    work_flow_node_t *new_node = (work_flow_node_t *)kdk_malloc(sizeof(work_flow_node_t));
    if(new_node == KDK_NULL)
        return KDK_NULL;

    memset(new_node->work_id, 0, WORK_ID_LEN + 1);
    strncpy(new_node->work_id, work_id, WORK_ID_LEN);
    new_node->node_next   = KDK_NULL;
    new_node->branch_flow = KDK_NULL;

    return new_node;
}

kdk_void 
work_flow_branch_runtime_clear(work_flow_branch_t *branch)
{
    if(branch == KDK_NULL) 
        return ;

    branch->node_current   = branch->node_flow;
    branch->branch_current = branch;
    branch->step = 0;

    return ;
}

work_flow_branch_t *
work_flow_branch_create(kdk_char32 *flow_id)
{
    if(flow_id == KDK_NULL) 
        return KDK_NULL;

    work_flow_branch_t *new_branch = (work_flow_branch_t *)kdk_malloc(sizeof(work_flow_branch_t));
    if(new_branch == KDK_NULL)
        return KDK_NULL;

    memset(new_branch->flow_id, 0, FLOW_ID_LEN + 1);
    strncpy(new_branch->flow_id, flow_id, FLOW_ID_LEN);
    new_branch->work_id_count = 0;
    new_branch->node_flow     = KDK_NULL;
    new_branch->branch_next   = KDK_NULL;

    work_flow_branch_runtime_clear(new_branch);

    return new_branch;
}

kdk_void 
work_flow_entry_destory(work_flow_branch_t *entry)
{
    work_flow_branch_t *branch_free;
    work_flow_node_t   *node_free;

    if(entry == KDK_NULL)
        return ;

    while(entry->node_flow != KDK_NULL)
    {
        while(entry->node_flow->branch_flow != KDK_NULL)
        {
            while(entry->node_flow->branch_flow->node_flow != KDK_NULL)
            {
                node_free                                = entry->node_flow->branch_flow->node_flow;
                entry->node_flow->branch_flow->node_flow = entry->node_flow->branch_flow->node_flow->node_next;
                kdk_free(node_free);
            }
            branch_free                   = entry->node_flow->branch_flow;
            entry->node_flow->branch_flow = entry->node_flow->branch_flow->branch_next;
            kdk_free(branch_free);
        }
        node_free        = entry->node_flow;
        entry->node_flow = entry->node_flow->node_next;
        kdk_free(node_free);
    }

    return ;
}

work_flow_branch_t *
work_flow_entry_create(kdk_char32 *flow_id, kdk_char32 *work_flow)
{
    kdk_uint32          ret_code    = 0, 
                        offset      = 0, 
                        stepset     = 0, 
                        status      = PROCESS_NOR_STATUS,
                        pre_status  = status;
    kdk_char32          temp_id[FLOW_ID_LEN + 1] = {0};
    work_flow_branch_t *entry, *branch;
    work_flow_node_t   *node;

    if(flow_id == KDK_NULL || work_flow == KDK_NULL)
        return KDK_NULL;

    entry = work_flow_branch_create(flow_id);
    if(entry == KDK_NULL)
        return KDK_NULL;

    while(offset <= strlen(work_flow))
    {
        pre_status = status;

        memset(temp_id, 0, sizeof(temp_id));
        ret_code = get_id_from_work_flow(work_flow + offset, temp_id, FLOW_ID_LEN + 1, &status, &stepset);
        if(ret_code)
            return KDK_NULL;

        offset = offset + stepset;

        if(strlen(temp_id) == 0)
            continue;

        if(pre_status == PROCESS_PRE_STATUS && status == PROCESS_ERR_STATUS)
        {
            branch = work_flow_branch_create(temp_id);
            if(branch == KDK_NULL)
            {
                work_flow_entry_destory(entry);
                return KDK_NULL;
            }

            if(entry->branch_current->node_current == KDK_NULL)
            {
                work_flow_entry_destory(entry);
                return KDK_NULL;
            }

            branch->branch_next = entry->branch_current->node_current->branch_flow;
            entry->branch_current->node_current->branch_flow = branch;
            entry->branch_current = branch;
        }
        else if(pre_status == PROCESS_PRE_STATUS && status == PROCESS_NOR_STATUS)
        {
            continue;
        }
        else if(pre_status == PROCESS_ERR_STATUS || pre_status == PROCESS_ERR_NOR_STATUS || pre_status == PROCESS_NOR_STATUS)
        {
            node = work_flow_node_create(temp_id); 
            if(node == KDK_NULL)
            {
                work_flow_entry_destory(entry);
                return KDK_NULL;
            }

            if(entry->branch_current->node_flow == KDK_NULL)
            {
                entry->branch_current->node_flow    = node;
                entry->branch_current->node_current = node;
            }
            else
            {
                entry->branch_current->node_current->node_next = node;
                entry->branch_current->node_current            = node;
            }

            (entry->branch_current->work_id_count)++;

            if(status == PROCESS_NOR_STATUS)
            {
                work_flow_branch_runtime_clear(entry->branch_current);
                entry->branch_current = entry;
            }
        }
        else
        {
            return KDK_NULL;
        }
    }

    work_flow_branch_runtime_clear(entry);

    return entry;
}

kdk_void 
work_flow_entry_print(work_flow_branch_t *entry)
{
    kdk_uint32      i = 0;

    if(entry == KDK_NULL)
        return ;

    fprintf(stderr,     "[FLOWID:%s]\n", entry->flow_id);
    while(entry->node_flow != KDK_NULL)
    {
        fprintf(stderr, "       |\n");
        fprintf(stderr, "     [%3s]\n", entry->node_flow->work_id);

        while(entry->node_flow->branch_flow != KDK_NULL)
        {
            if(i == 0)
            {
                fprintf(stderr, "       |---[ERR:%3s]", entry->node_flow->branch_flow->flow_id);
            }
            else
            {
                fprintf(stderr, "       |       |\n");
                fprintf(stderr, "       |   [ERR:%3s]", entry->node_flow->branch_flow->flow_id);
            }
            i++;

            while(entry->node_flow->branch_flow->node_flow != KDK_NULL)
            {
                fprintf(stderr, "-[%3s]", entry->node_flow->branch_flow->node_flow->work_id);
                entry->node_flow->branch_flow->node_flow = entry->node_flow->branch_flow->node_flow->node_next;
            }
            fprintf(stderr, "\n");
            entry->node_flow->branch_flow = entry->node_flow->branch_flow->branch_next;
        }
        i = 0;

        entry->node_flow = entry->node_flow->node_next;
    }
    fprintf(stderr, "       |\n");
    fprintf(stderr, "     [end]\n");

    return ;
}
